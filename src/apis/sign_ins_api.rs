/*
 * Clerk Frontend API
 *
 * The Clerk REST Frontend API, meant to be accessed from a browser or native environment.  This is a Form Based API and all the data must be sent and formatted according to the `application/x-www-form-urlencoded` content type.  ### Versions  When the API changes in a way that isn't compatible with older versions, a new version is released. Each version is identified by its release date, e.g. `2021-02-05`. For more information, please see [Clerk API Versions](https://clerk.com/docs/backend-requests/versioning/overview).  ### Using the Try It Console  The `Try It` feature of the docs only works for **Development Instances** when using the `DevBrowser` security scheme. To use it, first generate a dev instance token from the `/v1/dev_browser` endpoint.  Please see https://clerk.com/docs for more information.
 *
 * The version of the OpenAPI document: v1
 * Contact: support@clerk.com
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for typed errors of method [`accept_ticket`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AcceptTicketError {
    Status400(models::ClerkErrors),
    Status404(models::ClerkErrors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`attempt_sign_in_factor_one`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AttemptSignInFactorOneError {
    Status400(models::ClerkErrors),
    Status403(models::ClerkErrors),
    Status404(models::ClerkErrors),
    Status422(models::ClerkErrors),
    Status429(models::ClerkErrors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`attempt_sign_in_factor_two`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AttemptSignInFactorTwoError {
    Status400(models::ClerkErrors),
    Status403(models::ClerkErrors),
    Status422(models::ClerkErrors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_sign_in`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSignInError {
    Status400(models::ClerkErrors),
    Status403(models::ClerkErrors),
    Status404(models::ClerkErrors),
    Status409(models::ClerkErrors),
    Status422(models::ClerkErrors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_sign_in`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSignInError {
    Status400(models::ClerkErrors),
    Status401(models::ClerkErrors),
    Status404(models::ClerkErrors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`prepare_sign_in_factor_one`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrepareSignInFactorOneError {
    Status400(models::ClerkErrors),
    Status403(models::ClerkErrors),
    Status404(models::ClerkErrors),
    Status422(models::ClerkErrors),
    Status429(models::ClerkErrors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`prepare_sign_in_factor_two`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PrepareSignInFactorTwoError {
    Status400(models::ClerkErrors),
    Status403(models::ClerkErrors),
    Status422(models::ClerkErrors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reset_password`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResetPasswordError {
    Status400(models::ClerkErrors),
    Status422(models::ClerkErrors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`verify`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VerifyError {
    Status400(models::ClerkErrors),
    UnknownValue(serde_json::Value),
}

/// Parses a ticket JWT and performs the necessary actions depending on the ticket's source type. Depending on the ticket source type, a successful response can either redirect to a new location with the ticket in the query string, or respond directly with a text/html content type for the response body.
pub async fn accept_ticket(
    configuration: &configuration::Configuration,
    ticket: &str,
) -> Result<(), Error<AcceptTicketError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_ticket = ticket;

    let uri_str = format!("{}/v1/tickets/accept", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("ticket", &p_query_ticket.to_string())]);
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.query(&[("__dev_session", value)]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("__session", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AcceptTicketError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Attempt the first verification. Requires the sign in attempt to be identified, and the first factor verification to be prepared, unless you're using a password.  Parameter rules: If the strategy equals `email_code` or `phone_code` then a code is required. If the strategy equals `password` then a password is required.
pub async fn attempt_sign_in_factor_one(
    configuration: &configuration::Configuration,
    sign_in_id: &str,
    strategy: &str,
    origin: Option<&str>,
    code: Option<&str>,
    password: Option<&str>,
    signature: Option<&str>,
    token: Option<&str>,
    ticket: Option<&str>,
    public_key_credential: Option<&str>,
) -> Result<models::ClientClientWrappedSignIn, Error<AttemptSignInFactorOneError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_sign_in_id = sign_in_id;
    let p_form_strategy = strategy;
    let p_header_origin = origin;
    let p_form_code = code;
    let p_form_password = password;
    let p_form_signature = signature;
    let p_form_token = token;
    let p_form_ticket = ticket;
    let p_form_public_key_credential = public_key_credential;

    let uri_str = format!(
        "{}/v1/client/sign_ins/{sign_in_id}/attempt_first_factor",
        configuration.base_path,
        sign_in_id = crate::apis::urlencode(p_path_sign_in_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.query(&[("__dev_session", value)]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_origin {
        req_builder = req_builder.header("Origin", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("__session", value);
    };
    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("strategy", p_form_strategy.to_string());
    if let Some(param_value) = p_form_code {
        multipart_form_params.insert("code", param_value.to_string());
    }
    if let Some(param_value) = p_form_password {
        multipart_form_params.insert("password", param_value.to_string());
    }
    if let Some(param_value) = p_form_signature {
        multipart_form_params.insert("signature", param_value.to_string());
    }
    if let Some(param_value) = p_form_token {
        multipart_form_params.insert("token", param_value.to_string());
    }
    if let Some(param_value) = p_form_ticket {
        multipart_form_params.insert("ticket", param_value.to_string());
    }
    if let Some(param_value) = p_form_public_key_credential {
        multipart_form_params.insert("public_key_credential", param_value.to_string());
    }
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ClientClientWrappedSignIn`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ClientClientWrappedSignIn`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AttemptSignInFactorOneError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Attempt the second verification. Requires the sign in attempt `status` to be equal to `needs_second_factor`, and for the preparation step to have been called.
pub async fn attempt_sign_in_factor_two(
    configuration: &configuration::Configuration,
    sign_in_id: &str,
    strategy: Option<&str>,
    code: Option<&str>,
) -> Result<models::ClientClientWrappedSignIn, Error<AttemptSignInFactorTwoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_sign_in_id = sign_in_id;
    let p_form_strategy = strategy;
    let p_form_code = code;

    let uri_str = format!(
        "{}/v1/client/sign_ins/{sign_in_id}/attempt_second_factor",
        configuration.base_path,
        sign_in_id = crate::apis::urlencode(p_path_sign_in_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.query(&[("__dev_session", value)]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("__session", value);
    };
    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = p_form_strategy {
        multipart_form_params.insert("strategy", param_value.to_string());
    }
    if let Some(param_value) = p_form_code {
        multipart_form_params.insert("code", param_value.to_string());
    }
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ClientClientWrappedSignIn`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ClientClientWrappedSignIn`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AttemptSignInFactorTwoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Creates or replaces the current Sign in object. In order to authenticate a Sign in in as few requests as possible, you can pass in parameters to this request that can identify and verify the Sign in.  Parameter rules:  If the strategy equals `phone_code`, `email_code`, `web3_[provider]_signature`, `reset_password_code` or `reset_password_phone_code` then an identifier is required.  If the strategy equals `email_link` then an identifier is required and optionally redirect_url can be supplied.  If the strategy equals `password` then both an identifier and a password is required.  If the strategy equals `oauth_[provider]` or `saml` then a redirect_url is required, and an action_complete_redirect_url is optional.  If the strategy equals `oauth_token_[provider]` then at least one of code (grant code) or token (openID token) is required. Passing only the token will probably retrieve minimal information about the user from the OAuth provider. You can pass both code and token for the best results.  If the strategy equals `ticket` then ticket is required.  If the strategy equals `passkey` then no identifier is provided.  If the strategy equals `google_one_tap` then token is required.
pub async fn create_sign_in(
    configuration: &configuration::Configuration,
    origin: Option<&str>,
    strategy: Option<&str>,
    identifier: Option<&str>,
    password: Option<&str>,
    ticket: Option<&str>,
    redirect_url: Option<&str>,
    action_complete_redirect_url: Option<&str>,
    transfer: Option<bool>,
    code: Option<&str>,
    token: Option<&str>,
    oidc_login_hint: Option<&str>,
    oidc_prompt: Option<&str>,
) -> Result<models::ClientClientWrappedSignIn, Error<CreateSignInError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_header_origin = origin;
    let p_form_strategy = strategy;
    let p_form_identifier = identifier;
    let p_form_password = password;
    let p_form_ticket = ticket;
    let p_form_redirect_url = redirect_url;
    let p_form_action_complete_redirect_url = action_complete_redirect_url;
    let p_form_transfer = transfer;
    let p_form_code = code;
    let p_form_token = token;
    let p_form_oidc_login_hint = oidc_login_hint;
    let p_form_oidc_prompt = oidc_prompt;

    let uri_str = format!("{}/v1/client/sign_ins", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.query(&[("__dev_session", value)]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_origin {
        req_builder = req_builder.header("Origin", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("__session", value);
    };
    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = p_form_strategy {
        multipart_form_params.insert("strategy", param_value.to_string());
    }
    if let Some(param_value) = p_form_identifier {
        multipart_form_params.insert("identifier", param_value.to_string());
    }
    if let Some(param_value) = p_form_password {
        multipart_form_params.insert("password", param_value.to_string());
    }
    if let Some(param_value) = p_form_ticket {
        multipart_form_params.insert("ticket", param_value.to_string());
    }
    if let Some(param_value) = p_form_redirect_url {
        multipart_form_params.insert("redirect_url", param_value.to_string());
    }
    if let Some(param_value) = p_form_action_complete_redirect_url {
        multipart_form_params.insert("action_complete_redirect_url", param_value.to_string());
    }
    if let Some(param_value) = p_form_transfer {
        multipart_form_params.insert("transfer", param_value.to_string());
    }
    if let Some(param_value) = p_form_code {
        multipart_form_params.insert("code", param_value.to_string());
    }
    if let Some(param_value) = p_form_token {
        multipart_form_params.insert("token", param_value.to_string());
    }
    if let Some(param_value) = p_form_oidc_login_hint {
        multipart_form_params.insert("oidc_login_hint", param_value.to_string());
    }
    if let Some(param_value) = p_form_oidc_prompt {
        multipart_form_params.insert("oidc_prompt", param_value.to_string());
    }
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ClientClientWrappedSignIn`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ClientClientWrappedSignIn`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateSignInError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns the sign-in with the given id. The sign in is returned only if it belongs to the requesting client and is not abandoned.
pub async fn get_sign_in(
    configuration: &configuration::Configuration,
    sign_in_id: &str,
) -> Result<models::ClientClientWrappedSignIn, Error<GetSignInError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_sign_in_id = sign_in_id;

    let uri_str = format!(
        "{}/v1/client/sign_ins/{sign_in_id}",
        configuration.base_path,
        sign_in_id = crate::apis::urlencode(p_path_sign_in_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.query(&[("__dev_session", value)]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("__session", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ClientClientWrappedSignIn`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ClientClientWrappedSignIn`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSignInError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Prepares the verification object for the identified Sign in. This step authenticates that the user is who they say they are. Depending on the strategy, this request will do something different.  Parameter actions: If the strategy equals email_code then this request will send an email with an OTP code. If the strategy equals phone_code then this request will send an SMS with an OTP code. If the strategy equals oauth_[provider] then this request generate a URL that the User needs to visit in order to authenticate. If the strategy equals passkey then this request will begin the passkey registration flow.  Parameter rules: If the strategy equals `oauth_[provider]` then a redirect_url is required, and an action_complete_redirect_url is optional.
pub async fn prepare_sign_in_factor_one(
    configuration: &configuration::Configuration,
    sign_in_id: &str,
    strategy: &str,
    origin: Option<&str>,
    email_address_id: Option<&str>,
    phone_number_id: Option<&str>,
    web3_wallet_id: Option<&str>,
    passkey_id: Option<&str>,
    redirect_url: Option<&str>,
    action_complete_redirect_url: Option<&str>,
    oidc_login_hint: Option<&str>,
    oidc_prompt: Option<&str>,
) -> Result<models::ClientClientWrappedSignIn, Error<PrepareSignInFactorOneError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_sign_in_id = sign_in_id;
    let p_form_strategy = strategy;
    let p_header_origin = origin;
    let p_form_email_address_id = email_address_id;
    let p_form_phone_number_id = phone_number_id;
    let p_form_web3_wallet_id = web3_wallet_id;
    let p_form_passkey_id = passkey_id;
    let p_form_redirect_url = redirect_url;
    let p_form_action_complete_redirect_url = action_complete_redirect_url;
    let p_form_oidc_login_hint = oidc_login_hint;
    let p_form_oidc_prompt = oidc_prompt;

    let uri_str = format!(
        "{}/v1/client/sign_ins/{sign_in_id}/prepare_first_factor",
        configuration.base_path,
        sign_in_id = crate::apis::urlencode(p_path_sign_in_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.query(&[("__dev_session", value)]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_origin {
        req_builder = req_builder.header("Origin", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("__session", value);
    };
    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("strategy", p_form_strategy.to_string());
    if let Some(param_value) = p_form_email_address_id {
        multipart_form_params.insert("email_address_id", param_value.to_string());
    }
    if let Some(param_value) = p_form_phone_number_id {
        multipart_form_params.insert("phone_number_id", param_value.to_string());
    }
    if let Some(param_value) = p_form_web3_wallet_id {
        multipart_form_params.insert("web3_wallet_id", param_value.to_string());
    }
    if let Some(param_value) = p_form_passkey_id {
        multipart_form_params.insert("passkey_id", param_value.to_string());
    }
    if let Some(param_value) = p_form_redirect_url {
        multipart_form_params.insert("redirect_url", param_value.to_string());
    }
    if let Some(param_value) = p_form_action_complete_redirect_url {
        multipart_form_params.insert("action_complete_redirect_url", param_value.to_string());
    }
    if let Some(param_value) = p_form_oidc_login_hint {
        multipart_form_params.insert("oidc_login_hint", param_value.to_string());
    }
    if let Some(param_value) = p_form_oidc_prompt {
        multipart_form_params.insert("oidc_prompt", param_value.to_string());
    }
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ClientClientWrappedSignIn`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ClientClientWrappedSignIn`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PrepareSignInFactorOneError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Prepare the second verification. Requires the sign in attempt `status` to be equal to `needs_second_factor`.
pub async fn prepare_sign_in_factor_two(
    configuration: &configuration::Configuration,
    sign_in_id: &str,
    strategy: Option<&str>,
    phone_number_id: Option<&str>,
) -> Result<models::ClientClientWrappedSignIn, Error<PrepareSignInFactorTwoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_sign_in_id = sign_in_id;
    let p_form_strategy = strategy;
    let p_form_phone_number_id = phone_number_id;

    let uri_str = format!(
        "{}/v1/client/sign_ins/{sign_in_id}/prepare_second_factor",
        configuration.base_path,
        sign_in_id = crate::apis::urlencode(p_path_sign_in_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.query(&[("__dev_session", value)]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("__session", value);
    };
    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = p_form_strategy {
        multipart_form_params.insert("strategy", param_value.to_string());
    }
    if let Some(param_value) = p_form_phone_number_id {
        multipart_form_params.insert("phone_number_id", param_value.to_string());
    }
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ClientClientWrappedSignIn`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ClientClientWrappedSignIn`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PrepareSignInFactorTwoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Reset password on sign-in.
pub async fn reset_password(
    configuration: &configuration::Configuration,
    sign_in_id: &str,
    password: &str,
    sign_out_of_other_sessions: Option<bool>,
) -> Result<models::SchemasClientClientWrappedSignIn, Error<ResetPasswordError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_sign_in_id = sign_in_id;
    let p_form_password = password;
    let p_form_sign_out_of_other_sessions = sign_out_of_other_sessions;

    let uri_str = format!(
        "{}/v1/client/sign_ins/{sign_in_id}/reset_password",
        configuration.base_path,
        sign_in_id = crate::apis::urlencode(p_path_sign_in_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.query(&[("__dev_session", value)]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("__session", value);
    };
    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("password", p_form_password.to_string());
    if let Some(param_value) = p_form_sign_out_of_other_sessions {
        multipart_form_params.insert("sign_out_of_other_sessions", param_value.to_string());
    }
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SchemasClientClientWrappedSignIn`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SchemasClientClientWrappedSignIn`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ResetPasswordError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Attempt to verify a verification with email_link strategy.
pub async fn verify(
    configuration: &configuration::Configuration,
    token: &str,
) -> Result<(), Error<VerifyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_token = token;

    let uri_str = format!("{}/v1/verify", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("token", &p_query_token.to_string())]);
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.query(&[("__dev_session", value)]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("__session", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<VerifyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
